# TP_NFC Stability & Performance Improvements

## CRITICAL REQUIREMENT

**All improvements must preserve existing functionality completely. Read entire codebase before implementing any changes.**

- Current NFC scanning loops and timing is already short. Attempting optimization must be done with caution.
- All UI modes and transitions must continue working
- Thread synchronization patterns must be preserved
- No breaking changes to user workflow or interface
## Priority 1: Code Optimization 

### Memory Management
```python
# In app.py - prevent memory leaks from widget references
def cleanup_widgets(self):
    """Clean up widget references to prevent memory leaks"""
    if hasattr(self, 'guest_tree'):
        # Clear all items before destroying
        for item in self.guest_tree.get_children():
            self.guest_tree.delete(item)
    
    # Explicit cleanup of large data structures
    self.guests_data.clear()
    if hasattr(self, '_cached_guest_data'):
        self._cached_guest_data.clear()
```

### Thread Pool Management
```python
# Replace ad-hoc threading with managed pool
from concurrent.futures import ThreadPoolExecutor
import threading

class NFCApp:
    def __init__(self, ...):
        # Limit concurrent background operations
        self.thread_pool = ThreadPoolExecutor(max_workers=3)
        self._shutdown_event = threading.Event()
    
    def submit_background_task(self, func, *args):
        """Submit background task to managed pool"""
        if not self._shutdown_event.is_set():
            return self.thread_pool.submit(func, *args)
    
    def on_closing(self):
        self._shutdown_event.set()
        self.thread_pool.shutdown(wait=True, timeout=5)
```

### Resource Cleanup
```python
# Add proper context managers
class SafeNFCOperation:
    def __init__(self, nfc_service, operation_name):
        self.nfc_service = nfc_service
        self.operation_name = operation_name
        self.start_time = None
    
    def __enter__(self):
        self.start_time = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        duration = time.time() - self.start_time
        if duration > 10:  # Log slow operations
            logger.warning(f"{self.operation_name} took {duration:.2f}s")
```

## Priority 2: Stability Improvements

### Widget Safety Patterns
```python
# Extend existing safe widget pattern to all UI updates
def safe_update_widget(widget_attr, update_func, *args, **kwargs):
    """Safely update any widget with existence check"""
    try:
        widget = getattr(self, widget_attr, None)
        if widget and hasattr(widget, 'winfo_exists') and widget.winfo_exists():
            update_func(widget, *args, **kwargs)
    except Exception as e:
        self.logger.debug(f"Widget {widget_attr} update failed: {e}")

# Usage throughout app.py
self.safe_update_widget('status_label', lambda w, text, color: w.configure(text=text, text_color=color), message, color)
```

### Error Recovery
```python
# Add automatic recovery for common failures
class AutoRecovery:
    def __init__(self, max_failures=3, reset_interval=300):
        self.failure_counts = {}
        self.max_failures = max_failures
        self.reset_interval = reset_interval
    
    def record_failure(self, operation_name):
        now = time.time()
        if operation_name not in self.failure_counts:
            self.failure_counts[operation_name] = {'count': 0, 'last_reset': now}
        
        entry = self.failure_counts[operation_name]
        if now - entry['last_reset'] > self.reset_interval:
            entry['count'] = 0
            entry['last_reset'] = now
        
        entry['count'] += 1
        return entry['count'] >= self.max_failures
```

### Connection Health Monitoring
```python
# Add health checks without disrupting flow
def check_connections_health(self):
    """Non-intrusive health check"""
    health = {
        'nfc_connected': self.nfc_service.is_connected if hasattr(self.nfc_service, 'is_connected') else False,
        'sheets_auth_valid': self._check_sheets_auth(),
        'memory_usage': self._get_memory_usage()
    }
    
    # Update UI indicator (small dot in corner)
    self._update_health_indicator(health)
    
    # Schedule next check
    self.after(30000, self.check_connections_health)  # Every 30 seconds

def _check_sheets_auth(self):
    try:
        # Quick non-invasive check
        return hasattr(self.sheets_service, 'creds') and self.sheets_service.creds.valid
    except:
        return False
```

## Priority 3: Performance Monitoring (Lightweight)

### Basic Metrics Collection
```python
class PerformanceMonitor:
    def __init__(self):
        self.metrics = {
            'nfc_read_times': [],
            'ui_update_times': [],
            'sheets_call_times': []
        }
        self.max_samples = 100  # Keep only recent samples
    
    def record_time(self, operation, duration):
        if operation in self.metrics:
            times = self.metrics[operation]
            times.append(duration)
            if len(times) > self.max_samples:
                times.pop(0)  # Remove oldest
    
    def get_average_time(self, operation):
        times = self.metrics.get(operation, [])
        return sum(times) / len(times) if times else 0
```

### Memory Usage Tracking
```python
import psutil
import gc

def optimize_memory_usage(self):
    """Periodic memory optimization"""
    # Force garbage collection
    gc.collect()
    
    # Get current memory usage
    process = psutil.Process()
    memory_mb = process.memory_info().rss / 1024 / 1024
    
    # Log if memory usage is high
    if memory_mb > 200:  # More than 200MB
        self.logger.warning(f"High memory usage: {memory_mb:.1f}MB")
        
        # Clear cached data if needed
        if hasattr(self, '_cached_guest_data'):
            self._cached_guest_data.clear()
    
    # Schedule next check (every 5 minutes)
    self.after(300000, self.optimize_memory_usage)
```

## Priority 4: Configuration Optimization

### Reduce UI Update Frequency
```python
# Batch UI updates to reduce flicker
class UIUpdateBatcher:
    def __init__(self, delay_ms=50):
        self.pending_updates = {}
        self.delay_ms = delay_ms
    
    def schedule_update(self, update_key, update_func):
        """Batch multiple updates of same type"""
        self.pending_updates[update_key] = update_func
        self.after(self.delay_ms, self._flush_updates)
    
    def _flush_updates(self):
        for update_func in self.pending_updates.values():
            try:
                update_func()
            except Exception as e:
                self.logger.debug(f"Batched update failed: {e}")
        self.pending_updates.clear()
```

### Optimize Guest List Updates
```python
def optimize_guest_table_refresh(self):
    """Only update changed rows instead of rebuilding entire table"""
    if not hasattr(self, '_last_guest_snapshot'):
        self._last_guest_snapshot = {}
    
    current_data = {guest.original_id: guest for guest in self.guests_data}
    
    # Find changes
    for guest_id, guest in current_data.items():
        if guest_id not in self._last_guest_snapshot:
            self._add_guest_row(guest)  # New guest
        elif self._guest_data_changed(guest, self._last_guest_snapshot[guest_id]):
            self._update_guest_row(guest)  # Changed guest
    
    # Remove deleted guests
    for guest_id in self._last_guest_snapshot:
        if guest_id not in current_data:
            self._remove_guest_row(guest_id)
    
    self._last_guest_snapshot = current_data.copy()
```

## Implementation Steps

### Step 1: Widget Safety (Immediate)
1. Add `safe_update_widget()` method
2. Replace direct widget updates with safe calls
3. Add cleanup methods to prevent memory leaks

### Step 2: Thread Management (Week 1)
1. Replace threading.Thread with ThreadPoolExecutor  
2. Add proper shutdown handling
3. Implement resource cleanup contexts

### Step 3: Health Monitoring (Week 2)  
1. Add lightweight connection health checks
2. Implement basic performance metrics
3. Add memory usage monitoring

### Step 4: UI Optimization (Week 3)
1. Implement UI update batching
2. Optimize guest list refresh logic
3. Add configuration for update frequencies

## Testing Approach

### Stress Testing
```python
def stress_test_scanning():
    """Simulate rapid NFC operations"""
    for i in range(100):
        # Simulate tag detection without actual NFC
        fake_tag = NFCTag(f"TEST{i:04d}")
        self._process_fake_tag(fake_tag)
        time.sleep(0.1)  # 10 tags per second
```

### Memory Leak Detection
```python
def monitor_memory_leaks():
    """Track memory usage over time"""
    import tracemalloc
    tracemalloc.start()
    
    # Run normal operations...
    
    snapshot = tracemalloc.take_snapshot()
    top_stats = snapshot.statistics('lineno')[:10]
    for stat in top_stats:
        print(stat)
```

These improvements maintain current functionality while significantly improving stability and performance.